---
title: 《架构》DDD应用架构
date: 2024-09-03 10:00:00
categories:
  - [架构, DDD]
---

### 一、DDD的应用架构
领域驱动设计（DDD）主要包含以下几种应用架构：
- 分层架构
- 六边形架构
- 洋葱架构
- 整洁架构
- 清晰架构

<!--more-->

### 二、分层架构
DDD 的分层架构在不断发展。最早是传统的四层架构；后来四层架构有了进一步的优化，实现了各层对基础层的解耦；再后来领域层和应用层之间增加了上下文环境（Context）层，五层架构（DCI）就此形成了。
![传统4层架构](2024-09-01-架构-DDD分层架构/传统4层架构.png)
我们看一下上面这张图，在最早的传统四层架构中，**基础层是被其它层依赖的，它位于最核心的位置** ，那按照分层架构的思想，它应该就是核心，但实际上领域层才是软件的核心，所以这种依赖是有问题的。后来我们采用了依赖倒置（Dependency inversion principle,DIP）的设计，优化了传统的四层架构，实现了各层对基础层的解耦。

#### 2.1、分层说明
我们今天讲的 DDD 分层架构就是优化后的四层架构。在下面这张图中，从上到下依次是：用户接口层、应用层、领域层和基础层。那 DDD 各层的主要职责是什么呢？下面我来逐一介绍一下。
![分层架构](2024-09-01-架构-DDD分层架构/分层架构.png)
##### 用户接口层
用户接口层负责向用户显示信息和解释用户指令。这里的用户可能是：用户、程序、自动化测试和批处理脚本等等。

##### 应用层
只负责业务流程的串联，对不同领域的服务调用进行编排。          
事务控制一般在Application层， 在该层我们可以进行安全认证，权限校验，持久化事务控制，或者向其他系统发生基于事件的消息通知，也是作为领域层和用户接口层的桥梁。
命名规范：command入参为XxxCmdRequest，query入参为XxxQueryRequest

ApplicationService的接口入参只能是一个Command、Query或Event对象，CQE对象需要能代表当前方法的业务语意。 ApplicationService集中罗列系统核心的业务用例(Command)。读写（Command和Query）建议分开，放到不同的Service。
> 是协调领域层和其他外部系统的中间层。它不包含业务逻辑的核心部分，而是负责组织和调用领域层的服务来完成业务操作。例如，在电商系统的订单处理中，应用层会协调领域层的 “订单服务”、“库存服务” 和 “支付服务” 等来完成一个完整的下单流程。它起到了一个流程编排的作用，确保业务操作按照正确的顺序和规则进行。

##### 领域层
领域层的作用是实现企业核心业务逻辑，通过各种校验手段保证业务的正确性。领域层主要体现领域模型的业务能力，它用来表达业务概念、业务状态和业务规则。

领域层包含聚合根、实体、值对象、领域服务等领域模型中的领域对象。

这里我要特别解释一下其中几个领域对象的关系，以便你在设计领域层的时候能更加清楚。首先，领域模型的业务逻辑主要是由实体和领域服务来实现的，其中实体会采用充血模型来实现所有与之相关的业务功能。其次，你要知道，实体和领域对象在实现业务逻辑上不是同级的，当领域中的某些功能，单一实体（或者值对象）不能实现时，领域服务就会出马，它可以组合聚合内的多个实体（或者值对象），实现复杂的业务逻辑。
> 例如，在信贷系统中，领域层的 “信用评估服务” 会根据 “客户” 模型和 “贷款申请” 模型中的信息，运用复杂的信用评估算法来判断客户的信用等级，这就是领域服务在处理业务逻辑。

##### 基础层
基础层是贯穿所有层的，它的作用就是为其它各层提供通用的技术和基础服务，包括第三方工具、驱动、消息中间件、网关、文件、缓存以及数据库等。比较常见的功能还是提供数据库持久化。

基础层包含基础服务，它采用依赖倒置设计，封装基础资源服务，实现应用层、领域层与基础层的解耦，降低外部资源变化对应用的影响。

比如说，在传统架构设计中，由于上层应用对数据库的强耦合，很多公司在架构演进中最担忧的可能就是换数据库了，因为一旦更换数据库，就可能需要重写大部分的代码，这对应用来说是致命的。那采用依赖倒置的设计以后，应用层就可以通过解耦来保持独立的核心业务逻辑。当数据库变更时，我们只需要更换数据库基础服务就可以了，这样就将资源变更对应用的影响降到了最低。


#### 2.2、分层代码结构示例
系统架构：
![分层架构_系统架构](2024-09-01-架构-DDD分层架构/分层架构_系统架构.png)
包结构划分：
![分层架构_包结构划分](2024-09-01-架构-DDD分层架构/分层架构_包结构划分.png)
代码指导：
![分层架构_代码指示](2024-09-01-架构-DDD分层架构/分层架构_代码指示.png)


### 三、六边形架构
2005年，Alistair Cockburn提出了端口和适配器架构Ports & Adapters Architecture(又称六边形架构Hexagonal Architecture)。
![六边形架构](2024-09-01-架构-DDD分层架构/六边形架构.png)
端口和适配器架构中的相关概念：
- 工具Tools： 应用application使用的工具Tools(WebSerevr, Cli, DB, SearchEngine, MQ)
- 端口Port： 在application core层定义的工具交互规范（即定义 工具Tools如何使用application core的规范 或 工具Tools如何被application core使用的规范），对应编程语言的interface定义，且端口定义应该符合应用层逻辑（不可简单模仿或者直接使用底层工具的API）
- 适配器Adapter： 连接工具Tools(WebSerevr, Cli, DB, SearchEngine, MQ)和应用核心application core的代码单元
  - 适配器依赖port（调用port 或 实现port）和工具，但是application core仅依赖port。
- 主动适配器（Primary/Driving Adapters ） - 主动调用应用核心Application Core，触发应用执行某项活动
  - 主动适配器 -> 依赖端口 -> 注入端口实现，
  - 例如主动适配器Controller -> 依赖端口ServiceInterface -> 注入端口实现ServiceImpl
- 被动适配器（Secondary/Driven Adapters） - 被应用核心Application Core调用来执行动作，实现应用定义的端口
  - 端口 -->被动适配器实现端口逻辑-> 包装系统外部工具，
  - 例如端口RespositoryInterface -> 被动适配器Mysql实现MysqlRepositoryImpl -> 调用Mysql数据库

几边形不重要，可以N多边，重点是Port & Adapter思想，关于端口和适配器架构的优势：
- 核心业务在最中心（最重要），
- 核心业务依赖Port，Adapter依赖Port（主动） 或 Adapter为Port的具体实现（被动），
- 核心业务逻辑与实现细节（技术框架、底层存储、工具、传输通信机制等）相隔离，
- 保持核心业务逻辑的可重用性，
- 可通过（注入）不同Adapter实现来切换技术实现，避免技术框架、工具、供应商锁定，
- 且基于mock Port的形式更易于测试。


### 四、洋葱架构
洋葱架构（Onion Architecture） 在2008年由Jeffrey Palermo提出。
![洋葱架构](2024-09-01-架构-DDD分层架构/洋葱架构.png)
洋葱架构在DDD的基础上，将内层（业务逻辑层，Business Logic）进一步划分，最终为：
- **Adapters**，即六边形架构中的适配器Adapter层
  - User Interface、Infrastructure、Tests
- **Application Core，应用核心层**，也即原来的六边形架构中心的Business Logic层
  - **Application Services** - 应用服务册层
  - **Domain Services** - 领域服务层
  - **Domain Model** - 领域模型层

且明确了依赖方向：
- 外层依赖内层
- 内层不知道外层
- 且在不破坏依赖方向的前提下，外层亦可以直接调用任一内层（不一定是相邻接的2层），参考CQRS中Query实现（Application Services直接调用DAO）


在洋葱架构中，各层的职能是这样划分的：
- 领域模型实现领域内核心业务逻辑，它封装了企业级的业务规则。领域模型的主体是实体，一个实体可以是一个带方法的对象，也可以是一个数据结构和方法集合。
- 领域服务实现涉及多个实体的复杂业务逻辑。
- 应用服务实现与用户操作相关的服务组合与编排，它包含了应用特有的业务流程规则，封装和实现了系统所有用例。
- 最外层主要提供适配的能力，适配能力分为主动适配和被动适配。主动适配主要实现外部用户、网页、批处理和自动化测试等对内层业务逻辑访问适配。被动适配主要是实现核心业务逻辑对基础资源访问的适配，比如数据库、缓存、文件系统和消息中间件等。
- 红圈内的领域模型、领域服务和应用服务一起组成软件核心业务能力。



### 五、整洁架构【Clean Architecture】
2012年Robert C. Martin (又名Uncle Bob) 提出了整洁架构Clean Architecture，整洁架构将EBI、六边形架构Hexagonal、洋葱架构Onoin等整合成一个可以实际落地的架构。
![整洁架构](2024-09-01-架构-DDD分层架构/整洁架构.png)
与洋葱架构相比，整洁架构调整如下：
- Application Services调整为Use Cases
- Domain Services, Domain Model调整为Entities

整洁架构并没有带来突破性的概念或模式，但是：
- 它发掘了某种程度上被遗忘了的概念、规则和模式；
- 它澄清了一些实用且重要的概念、规则和模式；
- 它告诉我们如何把所有的概念、规则和模式整合起来，形成一种构建复杂应用并保持可维护性的标准套路

### 六、清晰架构
2017年Herberto Graca在其软件架构编年史系列文章中提出清晰架构Explicit Architecture，即将DDD, Hexagonal, Onion, Clean, CQRS等进行融合后的架构。
![清晰架构](2024-09-01-架构-DDD分层架构/清晰架构.png)
最中心的<font color=#e98787>**红色多边形**</font>Application Core即表示业务逻辑实现，即应用核心
- 红色多边形的边界即表示端口Port，即应用核心的入口/出口定义
- **Application Layer** - 应用层，包括：
  - **Application Services**，业务用例的编排服务即及其interface定义，应用服务的作用通常如下：
    - 使用 Repostitory 查找一个或多个实体；
    - 让这些实体执行一些领域逻辑；
    - 再次使用 Repostitory 让这些实体持久化，有效地保存数据变化；
    - 触发应用事件（如发送邮件、调用第三方API、发送MQ消息等）。
  - **CQRS命令/查询处理器**
  - **Event Listener事件监听器**
  - **Port端口定义**，如ORM 接口Repostitory、搜索引擎接口、消息接口等等
- **Domain Layer - 领域层**，这一层含了数据和操作数据的逻辑，它们只和领域本身有关，独立于调用这些逻辑的业务过程。它们完全独立，对应用层完全无感知。
  - **Domain Services - 领域服务**，封装涉及多实体（相同或不同实体类型）的领域逻辑，且领域服务间可以相互调用。
  - **Domain Models - 领域模型**，在架构的正中心，完全不依赖外部任何层次的领域模型。它包含了那些表示领域中某个概念的业务对象，如实体、值对象、枚举以及其它领域模型种用到的任何对象（如领域事件Domain Events，简单理解为MQ消息）。
- 红色多边形的外侧左半圆部分即为**主/主动适配器**（用户界面User Interface实现）
  - 如Spring MVC中的Controller实现
  - Command Query Bus 命令查询总线
- 红色多边形的外侧右半圆部分即**次/被动适配器**（基础设置Infrastructure实现）
  - 如数据持久化实现Mysql、短信通知实现、MQ通知、搜索引擎ES实现等
  - Event Bus 事件总线
- 依赖方向由外到内，且内层不知道外层（参见之前洋葱架构） 


>TIPS: 清晰架构只是一份指南！
应用才是疆域，现实情况和具体用例才是运用这些知识的地方，它们才能勾勒出实际架构的轮廓！
我们需要理解所有这些模式，
但我们还时常需要思考和理解我们的应用需要什么，我们应该在追求解耦和内聚的道路上走多远。
这个决定可能受到许多因素的影响，
包括项目的功能需求，也包括构建应用的时间期限，应用寿命，开发团队的经验等等因素。

### 七、关于传统分层、六边形、洋葱、整洁、清晰架构的演进可参见下图：
![总的架构演进图](2024-09-01-架构-DDD分层架构/总的架构演进图.png)


---

参考文章：
[DDD中常提到的应用架构总结（六边形、洋葱、整洁、清晰）](https://code84.com/730128.html)      
[微服务架构模型：几种常见模型的对比和分析](https://zq99299.github.io/note-book2/ddd/02/03.html#%E4%BB%8E%E4%B8%89%E7%A7%8D%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B%E7%9C%8B%E4%B8%AD%E5%8F%B0%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1)

EBI：
https://herbertograca.com/2017/08/24/ebi-architecture/

端口和适配器架构：
11.端口和适配器架构(译) - https://www.jianshu.com/p/f39f4537857e
https://herbertograca.com/2017/09/14/ports-adapters-architecture/

洋葱架构：
https://herbertograca.com/2017/09/21/onion-architecture/
https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/

整洁架构：
https://herbertograca.com/2017/09/28/clean-architecture-standing-on-the-shoulders-of-giants/
https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html

清晰架构：
https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/
17.清晰架构(01): 融合 DDD、洋葱架构、整洁架构、CQRS…(译) - https://www.jianshu.com/p/d3e8b9ac097b

DDD：
https://herbertograca.com/2017/09/07/domain-driven-design/