<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="一、I/O模型I/O（Input/Output）模型是指操作系统处理输入输出操作的不同方式。在计算机系统中，很多操作涉及到数据的输入和输出，比如从磁盘读取文件、从网络接收数据等。不同的 I/O 模型会影响程序的性能和资源利用效率。  磁盘IO 内存IO 网络IO">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="《Linux》io模型">
<meta property="og:url" content="http://yoursite.com/2020/03/13/2020-03-13-Linux-io模型/index.html">
<meta property="og:site_name" content="CHW&#39;s Notes">
<meta property="og:description" content="一、I/O模型I/O（Input/Output）模型是指操作系统处理输入输出操作的不同方式。在计算机系统中，很多操作涉及到数据的输入和输出，比如从磁盘读取文件、从网络接收数据等。不同的 I/O 模型会影响程序的性能和资源利用效率。  磁盘IO 内存IO 网络IO">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2020/03/13/2020-03-13-Linux-io模型/IO%E6%93%8D%E4%BD%9C%E7%9A%842%E4%B8%AA%E9%98%B6%E6%AE%B5.png">
<meta property="og:image" content="http://yoursite.com/2020/03/13/2020-03-13-Linux-io模型/sync-block.png">
<meta property="og:image" content="http://yoursite.com/2020/03/13/2020-03-13-Linux-io模型/sync-nonblock.png">
<meta property="og:image" content="http://yoursite.com/2020/03/13/2020-03-13-Linux-io模型/async-block.png">
<meta property="og:image" content="http://yoursite.com/2020/03/13/2020-03-13-Linux-io模型/bio.png">
<meta property="og:image" content="http://yoursite.com/2020/03/13/2020-03-13-Linux-io模型/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="http://yoursite.com/2020/03/13/2020-03-13-Linux-io模型/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="http://yoursite.com/2020/03/13/2020-03-13-Linux-io模型/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png">
<meta property="og:image" content="http://yoursite.com/2020/03/13/2020-03-13-Linux-io模型/%E5%90%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%80%97%E6%97%B6.png">
<meta property="og:updated_time" content="2025-01-14T01:49:33.313Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《Linux》io模型">
<meta name="twitter:description" content="一、I/O模型I/O（Input/Output）模型是指操作系统处理输入输出操作的不同方式。在计算机系统中，很多操作涉及到数据的输入和输出，比如从磁盘读取文件、从网络接收数据等。不同的 I/O 模型会影响程序的性能和资源利用效率。  磁盘IO 内存IO 网络IO">
<meta name="twitter:image" content="http://yoursite.com/2020/03/13/2020-03-13-Linux-io模型/IO%E6%93%8D%E4%BD%9C%E7%9A%842%E4%B8%AA%E9%98%B6%E6%AE%B5.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/03/13/2020-03-13-Linux-io模型/">





  <title>《Linux》io模型 | CHW's Notes</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CHW's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fa fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/13/2020-03-13-Linux-io模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CHW's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《Linux》io模型</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-13T15:43:10+08:00">
                2020-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/io/" itemprop="url" rel="index">
                    <span itemprop="name">io</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/io/多路复用/" itemprop="url" rel="index">
                    <span itemprop="name">多路复用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">阅读数
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="一、I-O模型"><a href="#一、I-O模型" class="headerlink" title="一、I/O模型"></a>一、I/O模型</h1><p>I/O（Input/Output）模型是指操作系统<strong>处理输入输出操作的不同方式</strong>。在计算机系统中，很多操作涉及到数据的输入和输出，比如从磁盘读取文件、从网络接收数据等。不同的 I/O 模型会影响程序的性能和资源利用效率。</p>
<ul>
<li>磁盘IO</li>
<li>内存IO</li>
<li>网络IO</li>
</ul>
<a id="more"></a>  

<h1 id="二、IO操作的2个阶段"><a href="#二、IO操作的2个阶段" class="headerlink" title="二、IO操作的2个阶段"></a>二、IO操作的2个阶段</h1><p><img src="/2020/03/13/2020-03-13-Linux-io模型/IO%E6%93%8D%E4%BD%9C%E7%9A%842%E4%B8%AA%E9%98%B6%E6%AE%B5.png" alt="IO操作的2个阶段"><br>操作系统完成IO操作的2个过程</p>
<ul>
<li><strong>数据准备阶段：</strong> 操作系统准备数据，把IO外部设备的数据，加载到内核缓冲区</li>
<li><strong>数据copy阶段：</strong> 操作系统copy数据，将内核缓冲区的数据，copy到用户进程缓冲区</li>
</ul>
<h1 id="三、先了解一下同步、异步、阻塞、非阻塞的相关概念。"><a href="#三、先了解一下同步、异步、阻塞、非阻塞的相关概念。" class="headerlink" title="三、先了解一下同步、异步、阻塞、非阻塞的相关概念。"></a>三、先了解一下同步、异步、阻塞、非阻塞的相关概念。</h1><h2 id="3-1、同步：一般指的是程序的顺序执行"><a href="#3-1、同步：一般指的是程序的顺序执行" class="headerlink" title="3.1、同步：一般指的是程序的顺序执行"></a>3.1、同步：一般指的是程序的顺序执行</h2><p>同步操作是指在一个任务执行过程中，调用者必须等待这个任务完成后才能继续执行其他操作。简单来说，就是一步一步按照顺序执行，前面的操作没有结束，后面的操作就不能开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A执行"</span>);</span><br><span class="line">        B();</span><br><span class="line">        System.out.println(<span class="string">"A执行完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B执行"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"B执行完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从该例子中，只有当B()执行完成后，A()方法才会输出”A执行完成”，这就是同步。<br>    整个处理过程顺序执行，当各个过程都执行完毕，并返回结果。是一种线性执行的方式，执行的流程不能跨越</p>
<h2 id="3-2、异步：ajax就是最好的例子"><a href="#3-2、异步：ajax就是最好的例子" class="headerlink" title="3.2、异步：ajax就是最好的例子"></a>3.2、异步：ajax就是最好的例子</h2><p>异步操作是指调用者发起一个任务后，不用等待这个任务完成就可以继续执行其他操作。当任务完成后，系统会通过某种方式（如回调函数、事件通知等）通知调用者任务已经完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function ajaxTest() &#123;</span><br><span class="line">    console.log(&quot;方法开始执行&quot;);</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: &quot;/A/remoteCall&quot;,</span><br><span class="line">        type: &quot;post&quot;,</span><br><span class="line">        success: function (data) &#123;</span><br><span class="line">            while(true) &#123;</span><br><span class="line">                console.log(&quot;方法开始执行&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(&quot;方法执行结束&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法执行，不需要等待ajax的返回结果。</p>
<h2 id="3-3、阻塞：一般指的是线程的状态"><a href="#3-3、阻塞：一般指的是线程的状态" class="headerlink" title="3.3、阻塞：一般指的是线程的状态"></a>3.3、阻塞：一般指的是线程的状态</h2><p>当一个操作是阻塞式操作时，执行这个操作的线程（或进程）会被挂起，直到这个操作完成。在阻塞期间，线程不能执行其他任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result export) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream inputStream = <span class="keyword">new</span> ByteArrayInputStream(ExcelUtil.getInstance().export(excelDataList, map, groupIdNameMap).toByteArray());</span><br><span class="line">            FileCopyUtils.copy(inputStream, outputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"导出Excel出错了"</span>, e);</span><br><span class="line">            result.setMessage(<span class="string">"操作失败!"</span>);</span><br><span class="line">            result.setStatus(REST_STATUS.FAILD_EXCEPTION);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例如导出中，操作系统读取文件返回花较长时间，程序不会往下执行，进入阻塞状态。    </p>
</blockquote>
<h2 id="3-4、非阻塞"><a href="#3-4、非阻塞" class="headerlink" title="3.4、非阻塞"></a>3.4、非阻塞</h2><p>非阻塞操作是指当执行一个操作时，如果操作不能立即完成，系统不会让线程（或进程）等待，而是返回一个提示（如错误码），线程可以继续执行其他操作。</p>
<p><font color="red"><strong>同步 / 异步主要关注的是任务的执行顺序和通知机制，而阻塞 / 非阻塞主要关注的是线程（或进程）在操作执行过程中的状态。</strong></font></p>
<p>More info: <a href="https://www.jianshu.com/p/aed6067eeac9" target="_blank" rel="noopener">参考文章</a>    </p>
<h1 id="四、Linux-IO模型"><a href="#四、Linux-IO模型" class="headerlink" title="四、Linux IO模型"></a>四、Linux IO模型</h1><ol>
<li>阻塞IO（bloking IO）</li>
<li>非阻塞IO（non-blocking IO）</li>
<li>多路复用IO（multiplexing IO）</li>
<li>信号驱动式IO（signal-driven IO）</li>
<li>异步IO（asynchronous IO）                </li>
</ol>
<h2 id="4-1、同步阻塞IO"><a href="#4-1、同步阻塞IO" class="headerlink" title="4.1、同步阻塞IO"></a>4.1、同步阻塞IO</h2><p><img src="/2020/03/13/2020-03-13-Linux-io模型/sync-block.png" alt="Linux-io模型"></p>
<ul>
<li><p>两个步骤：</p>
<ol>
<li>步骤一：用户空间的应用程序执行一个系统调用（recvform），linux kernel开始IO的第一阶段：准备数据。这会导致应用程序阻塞（进程自己选择的阻塞），什么也不干，直到数据准备好。</li>
<li>步骤二：当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞。</li>
</ol>
</li>
</ul>
<h2 id="4-2、同步非阻塞IO"><a href="#4-2、同步非阻塞IO" class="headerlink" title="4.2、同步非阻塞IO"></a>4.2、同步非阻塞IO</h2><p><img src="/2020/03/13/2020-03-13-Linux-io模型/sync-nonblock.png" alt="Linux-io模型"></p>
<blockquote>
<p>同步非阻塞就是通过轮训的方式（轮训执行系统调用），去判断数据是否准备好（轮训者：程序进程）<br>需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</p>
</blockquote>
<h2 id="4-3、IO多路复用"><a href="#4-3、IO多路复用" class="headerlink" title="4.3、IO多路复用"></a>4.3、IO多路复用</h2><p><img src="/2020/03/13/2020-03-13-Linux-io模型/async-block.png" alt="Linux-io模型"></p>
<blockquote>
<p>强调一点就是，IO多路复用模型并没有涉及到非阻塞，进程在发出select后，要一直阻塞等待其监听的所有IO操作至少有一个数据准备好才返回，强调阻塞状态，不存在非阻塞。<br>而在 Java NIO中也可以实现多路复用，主要是利用多路复用器 Selector，与这里的 select函数类型，Selector会不断轮询注册在其上的通道Channel，如果有某一个Channel上面发生读或写事件，这个Channel处于就绪状态，就会被Selector轮询出来。关于Java NIO实现多路复用更多的介绍请查询相关文章。</p>
</blockquote>
<h1 id="五、IO多路复用"><a href="#五、IO多路复用" class="headerlink" title="五、IO多路复用"></a>五、IO多路复用</h1><p>我们以最简单 socket 网络模型，一步一步的到 I/O 多路复用。</p>
<h2 id="5-1、最基本的-Socket-模型"><a href="#5-1、最基本的-Socket-模型" class="headerlink" title="5.1、最基本的 Socket 模型"></a>5.1、最基本的 Socket 模型</h2><p>要想客户端和服务器能在网络中通信，那必须得使用 Socket  编程，它是进程间通信里比较特别的方式，特别之处在于它是可以跨主机间通信。</p>
<p><code>Socket</code>的中文名叫作插口，咋一看还挺迷惑的。事实上，双方要进行网络通信前，各自得创建一个 Socket，这相当于客户端和服务器都开了一个“口子”，双方读取和发送数据的时候，都通过这个“口子”。这样一看，是不是觉得很像弄了一根网线，一头插在客户端，一头插在服务端，然后进行通信。</p>
<p>如下为socket示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//服务端的监听socket，只负责监听连接，监听的端口是：9878</span></span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9878</span>));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//可以进行下一次的通信</span></span><br><span class="line">                System.out.println(<span class="string">"等待连接"</span>);</span><br><span class="line">                Socket accept = serverSocket.accept();<span class="comment">//服务端进程将阻塞(将释放CPU资源)，直至连接请求过来，然后会生成一个socket</span></span><br><span class="line">                <span class="comment">//accept，这个socket是负责和客户端数据交换的</span></span><br><span class="line">                System.out.println(<span class="string">"连接成功"</span>);</span><br><span class="line">                System.out.println(<span class="string">"等待数据"</span>);</span><br><span class="line">                <span class="keyword">int</span> readCount = accept.getInputStream().read(bs);<span class="comment">//read也将阻塞</span></span><br><span class="line">                System.out.println(<span class="string">"数据获取成功"</span>);</span><br><span class="line">                System.out.println(<span class="string">"读取的数量="</span> + readCount);</span><br><span class="line">                String content = bs.toString();</span><br><span class="line">                System.out.println(<span class="string">"读取的内容为："</span> + content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket();</span><br><span class="line">        socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">9878</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TCP 协议的 Socket 程序的调用整个过程如下图：<br><img src="/2020/03/13/2020-03-13-Linux-io模型/bio.png" alt="bio"></p>
<ul>
<li>服务端会有2种socket<ul>
<li>监听socket：即绑定端口的socket，监听客户端的请求。</li>
<li>连接socket：服务端监听到有客户端连接时，accept()方法会生成一个新的连接socket</li>
</ul>
</li>
</ul>
<p>TCP Socket 调用流程是最简单、最基本的，<font color="green"><strong>它基本只能一对一通信，因为使用的是同步阻塞的方式</strong></font>，当服务端在还没处理完一个客户端的网络 I/O 时，或者 读写操作发生阻塞时，其他客户端是无法与服务端连接的。</p>
<h2 id="5-2、如何服务更多的用户？"><a href="#5-2、如何服务更多的用户？" class="headerlink" title="5.2、如何服务更多的用户？"></a>5.2、如何服务更多的用户？</h2><p>可如果我们服务器只能服务一个客户，那这样就太浪费资源了，于是我们要改进这个网络 I/O 模型，以支持更多的客户端。<br>在改进网络 I/O 模型前，我先来提一个问题，你知道服务器单机理论最大能连接多少个客户端？<br>相信你知道 TCP 连接是由四元组唯一确认的，这个四元组就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本机IP, 本机端口, 对端IP, 对端端口</span><br></pre></td></tr></table></figure>

<p>服务器作为服务方，通常会在本地固定监听一个端口，等待客户端的连接。因此服务器的本地 IP 和端口是固定的，于是对于服务端 TCP 连接的四元组只有对端 IP 和端口是会变化的，所以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大 TCP 连接数 = 客户端 IP 数×客户端端口数</span><br></pre></td></tr></table></figure>

<p>对于 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是</p>
<blockquote>
<p>服务端单机最大 TCP 连接数约为 2 的 48 次方</p>
</blockquote>
<p>这个理论值相当“丰满”，但是服务器肯定承载不了那么大的连接数，主要会受两个方面的限制：</p>
<ul>
<li><strong>文件描述符</strong> ，Socket 实际上是一个文件，也就会对应一个文件描述符。在 Linux 下，单个进程打开的文件描述符数是有限制的，没有经过修改的值一般都是 1024，不过我们可以通过 ulimit 增大文件描述符的数目；</li>
<li><strong>系统内存</strong>，每个 TCP 连接在内核中都有对应的数据结构，意味着每个连接都是会占用一定内存的；</li>
</ul>
<p>那如果服务器的内存只有 2 GB，网卡是千兆的，能支持并发 1 万请求吗？</p>
<blockquote>
<p>并发 1 万请求，也就是经典的 C10K 问题 ，C 是 Client 单词首字母缩写，C10K 就是单机同时处理 1 万个请求的问题。<br>从硬件资源角度看，对于 2GB 内存千兆网卡的服务器，如果每个请求处理占用不到 200KB 的内存和 100Kbit 的网络带宽就可以满足并发 1 万个请求。</p>
</blockquote>
<p>不过，要想真正实现 C10K 的服务器，要考虑的地方在于服务器的网络 I/O 模型，效率低的模型，会加重系统开销，从而会离 C10K 的目标越来越远。</p>
<h3 id="5-2-1、多进程模型【升级1】"><a href="#5-2-1、多进程模型【升级1】" class="headerlink" title="5.2.1、多进程模型【升级1】"></a>5.2.1、多进程模型【升级1】</h3><p>多线程模型，也就是为每个客户端分配一个进程来处理请求。<br><img src="/2020/03/13/2020-03-13-Linux-io模型/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="多进程模型"><br>服务器的主进程负责监听客户的连接，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过<code>fork()</code> 函数创建一个子进程，实际上就把父进程所有相关的东西都<strong>复制</strong>一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。</p>
<p>缺点：</p>
<blockquote>
<p>这种用多个进程来应付多个客户端的方式，在应对 100 个客户端还是可行的，但是当客户端数量高达一万时，肯定扛不住的，因为每产生一个进程，必会占据一定的系统资源，而且进程间上下文切换的“包袱”是很重的，性能会大打折扣。进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</p>
</blockquote>
<h3 id="5-2-2、多线程模型【升级2】"><a href="#5-2-2、多线程模型【升级2】" class="headerlink" title="5.2.2、多线程模型【升级2】"></a>5.2.2、多线程模型【升级2】</h3><p>既然进程间上下文切换的“包袱”很重，那我们就搞个比较轻量级的模型来应对多用户的请求</p>
<p>当服务器与客户端 TCP 完成连接后，通过<code>pthread_create()</code> 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。</p>
<p>如果每来一个连接就创建一个线程，线程运行完后，还得操作系统还得销毁线程，虽说线程切换的上写文开销不大，但是如果频繁创建和销毁线程，系统开销也是不小的。那么，我们可以使用<strong>线程池</strong>的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理。<br><img src="/2020/03/13/2020-03-13-Linux-io模型/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="多线程模型"></p>
<blockquote>
<p>上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程/线程，操作系统就算死扛也是扛不住的。</p>
</blockquote>
<h3 id="5-2-3、多路复用【升级3】"><a href="#5-2-3、多路复用【升级3】" class="headerlink" title="5.2.3、多路复用【升级3】"></a>5.2.3、多路复用【升级3】</h3><p>既然为每个请求分配一个进程/线程的方式不合适，那有没有可能只使用一个进程来维护多个 Socket 呢？答案是有的，那就是：多路复用。</p>
<p>不管是多进程模型还是多线程模型，都是需要用户进程或线程去主动的获取socket，多路复用的思想就是使用一个内核进程来维护多个socket。<br><img src="/2020/03/13/2020-03-13-Linux-io模型/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="多路复用"></p>
<h2 id="5-3、多路复用实现"><a href="#5-3、多路复用实现" class="headerlink" title="5.3、多路复用实现"></a>5.3、多路复用实现</h2><h3 id="5-3-1、selector"><a href="#5-3-1、selector" class="headerlink" title="5.3.1、selector"></a>5.3.1、selector</h3><p>当使用select函数的时候，先通知内核挂起进程，一旦一个或者多个IO事情发生，控制权将返回给应用程序，然后由应用程序进行IO处理。</p>
<blockquote>
<p>定期轮询，将管理的fd发送给内核，交给内核管理</p>
</blockquote>
<p>那么IO事件都包含哪些</p>
<ul>
<li>标准输入文件描述符可以读</li>
<li>已连接套接字准备好可以写</li>
<li>如果一个IO事件等待超过10秒，发生超时</li>
</ul>
<p>select使用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int select(int maxfdp, fd_set *readset, fd_set *writeset, fd_set *exceptset,struct timeval *timeout);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>readset：</strong> 管理的读fd</li>
<li><strong>writeset：</strong> 管理的写fd</li>
<li><strong>exceptset：</strong> 管理的异常fd</li>
</ul>
<p>select 会遍历每个集合的前 nfds 个描述符，分别找到可以读取、可以写入、发生错误的描述符，统称为“就绪”的描述符。然后用找到的子集替换参数中的对应集合，返回所有就绪描述符的总数</p>
<p>缺点</p>
<ul>
<li>只能支持1024个fd【内核以数组方式存储】</li>
<li>每次需更新，重复传递fd</li>
<li>每次内核被调用后，都需要遍历一遍所有的fd ：O(n)的时间复杂度</li>
</ul>
<h3 id="5-3-2、poll"><a href="#5-3-2、poll" class="headerlink" title="5.3.2、poll"></a>5.3.2、poll</h3><blockquote>
<p>鉴于select所支持的描述符有限，随后提出poll解决这个问题</p>
</blockquote>
<p>还是先看声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br></pre></td></tr></table></figure>

<ul>
<li>fds：文件描述符数组</li>
<li>nfds：表示fds数组中元素的个数。</li>
</ul>
<p>再看pollfd结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">    int   fd;         /* 文件描述符 */</span><br><span class="line">    short events;     /* 描述符待检测的事件 */</span><br><span class="line">    short revents;    /* returned events */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相对优点</p>
<ul>
<li>不限制文件描述符个数【用户态通过数组方式传递文件描述符，在内核会转为链表方式存储，没有最大数量的限制】</li>
</ul>
<p>缺点</p>
<ul>
<li>每次需更新，重复传递fd</li>
<li>每次内核被调用后，都需要遍历一遍所有的fd ：O(n)的时间复杂度</li>
</ul>
<h3 id="5-3-3、epoll"><a href="#5-3-3、epoll" class="headerlink" title="5.3.3、epoll"></a>5.3.3、epoll</h3><p>epoll 是 Linux 内核中用于高效处理 I/O 多路复用的机制。它的基本原理是基于事件驱动，通过在内核中维护一个事件表来实现对多个文件描述符（file descriptor）的监视。</p>
<p>在The Linux Programming Interface有张图展示三种IO复用技术在面对不同文件描述符时的差异<br><img src="/2020/03/13/2020-03-13-Linux-io模型/%E5%90%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%80%97%E6%97%B6.png" alt="各多路复用耗时"></p>
<h4 id="5-3-3-1、编程三步骤"><a href="#5-3-3-1、编程三步骤" class="headerlink" title="5.3.3.1、编程三步骤"></a>5.3.3.1、编程三步骤</h4><p>当应用程序使用 epoll 时：</p>
<ul>
<li>首先通过epoll_create系统调用创建一个 epoll 实例，这个实例可以看作是一个包含了文件描述符和相关事件的 “容器”。</li>
<li>然后使用epoll_ctl系统调用向这个容器中添加、修改或删除要监视的文件描述符及其对应的事件类型（如可读、可写、异常等）。</li>
<li>最后，通过epoll_wait系统调用阻塞等待事件的发生。当有文件描述符上的事件发生时，epoll_wait会返回，并且返回的信息中包含了发生事件的文件描述符和对应的事件类型。</li>
</ul>
<h5 id="1-epoll-create"><a href="#1-epoll-create" class="headerlink" title="1. epoll_create"></a>1. epoll_create</h5><p>首先通过epoll_create系统调用创建一个 epoll 实例，这个实例可以看作是一个包含了文件描述符和相关事件的 “容器”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size);</span><br></pre></td></tr></table></figure>

<h5 id="2-epoll-ctl"><a href="#2-epoll-ctl" class="headerlink" title="2. epoll_ctl"></a>2. epoll_ctl</h5><p>然后使用epoll_ctl系统调用向这个容器中添加、修改或删除要监视的文件描述符及其对应的事件类型（如可读、可写、异常等）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br></pre></td></tr></table></figure>

<h5 id="3-epoll-wait"><a href="#3-epoll-wait" class="headerlink" title="3. epoll_wait"></a>3. epoll_wait</h5><p>最后，通过epoll_wait系统调用阻塞等待事件的发生。当有文件描述符上的事件发生时，epoll_wait会返回，并且返回的信息中包含了发生事件的文件描述符和对应的事件类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</span><br><span class="line">//返回值: 成功返回的是一个大于 0 的数，表示事件的个数；返回 0 表示的是超时时间到；若出错返回 -1</span><br></pre></td></tr></table></figure>

<h4 id="5-3-3-2、epoll的底层实现"><a href="#5-3-3-2、epoll的底层实现" class="headerlink" title="5.3.3.2、epoll的底层实现"></a>5.3.3.2、epoll的底层实现</h4><ul>
<li>当我们使用epoll_fd增加一个fd的时候，内核会为我们创建一个epitem实例，将这个实例作为<font color="red"><strong>红黑树</strong></font>的节点。</li>
<li>随后查找的每一个fd是否有事件发生就是通过红黑树的epitem来操作</li>
<li>epoll维护一个<font color="red"><strong>链表</strong></font>来记录就绪事件，内核会当每个文件有事件发生的时候将自己登记到这个就绪列表，然后通过内核自身的文件file-eventpoll之间的回调和唤醒机制，减少对内核描述字的遍历，大俗事件通知和检测的效率</li>
</ul>
<p>More info:<a href="https://www.jianshu.com/p/486b0965c296" target="_blank" rel="noopener">参考文章</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/11/2020-03-11-Linux-零拷贝/" rel="next" title="《Linux》零拷贝">
                <i class="fa fa-chevron-left"></i> 《Linux》零拷贝
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/16/2020-03-16-网络-tcp/" rel="prev" title="《网络》TCP">
                《网络》TCP <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/touxiang.jpg" alt="chw">
            
              <p class="site-author-name" itemprop="name">chw</p>
              <p class="site-description motion-element" itemprop="description">do somthing</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">114</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、I-O模型"><span class="nav-text">一、I/O模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、IO操作的2个阶段"><span class="nav-text">二、IO操作的2个阶段</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、先了解一下同步、异步、阻塞、非阻塞的相关概念。"><span class="nav-text">三、先了解一下同步、异步、阻塞、非阻塞的相关概念。</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1、同步：一般指的是程序的顺序执行"><span class="nav-text">3.1、同步：一般指的是程序的顺序执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2、异步：ajax就是最好的例子"><span class="nav-text">3.2、异步：ajax就是最好的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3、阻塞：一般指的是线程的状态"><span class="nav-text">3.3、阻塞：一般指的是线程的状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4、非阻塞"><span class="nav-text">3.4、非阻塞</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、Linux-IO模型"><span class="nav-text">四、Linux IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1、同步阻塞IO"><span class="nav-text">4.1、同步阻塞IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2、同步非阻塞IO"><span class="nav-text">4.2、同步非阻塞IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3、IO多路复用"><span class="nav-text">4.3、IO多路复用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、IO多路复用"><span class="nav-text">五、IO多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1、最基本的-Socket-模型"><span class="nav-text">5.1、最基本的 Socket 模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2、如何服务更多的用户？"><span class="nav-text">5.2、如何服务更多的用户？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1、多进程模型【升级1】"><span class="nav-text">5.2.1、多进程模型【升级1】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2、多线程模型【升级2】"><span class="nav-text">5.2.2、多线程模型【升级2】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3、多路复用【升级3】"><span class="nav-text">5.2.3、多路复用【升级3】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3、多路复用实现"><span class="nav-text">5.3、多路复用实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1、selector"><span class="nav-text">5.3.1、selector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2、poll"><span class="nav-text">5.3.2、poll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-3、epoll"><span class="nav-text">5.3.3、epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-1、编程三步骤"><span class="nav-text">5.3.3.1、编程三步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-epoll-create"><span class="nav-text">1. epoll_create</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-epoll-ctl"><span class="nav-text">2. epoll_ctl</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-epoll-wait"><span class="nav-text">3. epoll_wait</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-2、epoll的底层实现"><span class="nav-text">5.3.3.2、epoll的底层实现</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chw</span>


       <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
 

</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
